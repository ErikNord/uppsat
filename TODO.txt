// TODO: Two notions of equality, one general and one per-theory (cf, object identity and -0 = +0)

// TODO: Symbol generation - use HashTable to store and re-use

// TODO: Reimplement the IJCAR
// TODO: At least as good as the z3-prototype.

// TODO: Longer research paper with design decision.

// Write down design decisions!

// Model reconstruction
 How do we deal with testing the hat-model. Testing and fixing every sub-formula could be expensive? (Loads of calls to the underlying solver). Maybe not a problem?

Plan:
1> Boolean theory, w. syntactic sugar and translator. half a day (done)
2> Integer theory, w. encoder and model reconstructor. two days
3> Floating theory w. everything! seven days.

APC: What about Equality? Special EqualityNode subclassed by each theory. Meta-equality vs fp.eq?

APC: Multi-layered approximations: 
	1) Support them directly.
	2) Call the framework as a back-end.


OLD CODE:
//
//  object FPFactory extends IndexedSortFactory { 
//    case class FPSort(eBits : Int, sBits : Int) extends IndexedSort {
//      val name = "Floating Point (" + eBits + ", " + sBits + ")"
//      val toSMTLib = "(_ FloatingPoint " + eBits + " " + sBits +")"
//      val getFactory = FPFactory
//    }
//
//    val rank = 2
//    def apply(idx : Seq[BigInt]) = {
//      val eBits = idx(0).toInt
//      val sBits = idx(1).toInt
//      // Anonymous class, notation!
//      // Maybe use HashTable to store and re-use
//      new FPSort(eBits, sBits)
//    }
//  }
// 
//
//  object RoundingModeSort extends ConcreteSort {
//    val name = "RoundingMode"
//    val toSMTLib = "RoundingMode"
//  }
//  
  
  // TODO: Change factory to something else?
//  class FPOpFactory(op : String) extends IndexedFunctionSymbolFactory {
//    val thisFactory = this
//    
//    // TODO: This should only be Symbol, since each instance of the factory will have it's own instance of the class
//    case class FPAddFunctionSymbol(arg1 : Sort, arg2 : Sort, res : Sort) extends IndexedFunctionSymbol {
//      val sort = res
//      val name = "Floating Point Addition with " + sort
//      val toSMTLib = "fp.add"
//      val args = List(RoundingModeSort, arg1, arg2)
//      val getFactory = thisFactory
//    }
//
//    val rank = 1
//    override def apply(sorts : Seq[Sort]) = {
//      op match {
//        // TODO: Pass integers instead of sorts?
//        case "fp.add" => new FPAddFunctionSymbol(sorts(0), sorts(1), sorts(2)) 
//      }
//      
//    }
//    
//    // TODO: Unapply should check if the argument symbol is of a instance fpfunctionsymbol and then pick it apart
//    // def unapply(FunctionSymbol : TypedFunctionSymbol) 
//    
//  }

//    val fp2_2 = FPFactory(List(2, 2))
//    println("fp2_2: (" + fp2_2.getClass + ") = " + fp2_2)
//    val fpAddFactory = new FPOpFactory("fp.add")
//    val fpAdd2_2 = fpAddFactory(List(fp2_2, fp2_2, fp2_2))
//    println("fpAdd2_2: (" + fpAdd2_2.getClass + ") = " + fpAdd2_2)



OLD TREE CODE:
    def mapUpDown(f : D => D) : Tree[D] = {
      val newD = f(d)
      val newChildren = children map (_ map f)
      Tree(f(newD), newChildren)
    }
    
    
    def zip[E](t : Tree[E]) : Tree[(D, E)] = t match {
      case Tree(e, children2) =>
        Tree((d, e),
             for ((c1, c2) <- children zip children2)
             yield (c1 zip c2))
    }
    def unzip[D1, D2](implicit asPair: D => (D1, D2)): (Tree[D1], Tree[D2]) = {
      val (children1, children2) = (for (c <- children) yield c.unzip).unzip
      val (d1, d2) = asPair(d)
      (Tree(d1, children1), Tree(d2, children2))
    }
    
        def subtrees : Tree[Tree[D]] =
      Tree(this, for (c <- children) yield c.subtrees)
    def toList : List[D] = iterator.toList
    def toSeq = toList
    
    
object Leaf {
  def apply[D](d : D) = Tree(d, List())
  def unapply[D](t : Tree[D]) : Option[D] = t match {
    case Tree(d, List()) => Some(d)
    case _ => None
  }
}    