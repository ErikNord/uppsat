// Introduce theory (e.g., first Boolean later Floats (maybe Int in between))

// Hardcode formula (shouldn't be too hard)

// TODO: Two notions of equality, one general and one per-theory (cf, object identity and -0 = +0)

// TODO: Symbol generation - use HashTable to store and re-use

// TODO: Reimplement the IJCAR
// TODO: At least as good as the z3-prototype.

// TODO: Longer research paper with design decision.

// Write down design decisions!

// Model reconstruction
How do we deal with testing the hat-model. Testing and fixing every sub-formula could be expensive? (Loads of calls to the underlying solver). Maybe not a problem?

Plan:
1> Boolean theory, w. syntactic sugar and translator. half a day (done)
2> Integer theory, w. encoder and model reconstructor. two days
3> Floating theory w. everything! seven days.

APC: What about Equality? Special EqualityNode subclassed by each theory

APC: Multi-layered approximations: 
	1) Support them directly.
	2) Call the framework as a back-end.


OLD CODE:
//
//  object FPFactory extends IndexedSortFactory { 
//    case class FPSort(eBits : Int, sBits : Int) extends IndexedSort {
//      val name = "Floating Point (" + eBits + ", " + sBits + ")"
//      val toSMTLib = "(_ FloatingPoint " + eBits + " " + sBits +")"
//      val getFactory = FPFactory
//    }
//
//    val rank = 2
//    def apply(idx : Seq[BigInt]) = {
//      val eBits = idx(0).toInt
//      val sBits = idx(1).toInt
//      // Anonymous class, notation!
//      // Maybe use HashTable to store and re-use
//      new FPSort(eBits, sBits)
//    }
//  }
// 
//
//  object RoundingModeSort extends ConcreteSort {
//    val name = "RoundingMode"
//    val toSMTLib = "RoundingMode"
//  }
//  
  
  // TODO: Change factory to something else?
//  class FPOpFactory(op : String) extends IndexedFunctionSymbolFactory {
//    val thisFactory = this
//    
//    // TODO: This should only be Symbol, since each instance of the factory will have it's own instance of the class
//    case class FPAddFunctionSymbol(arg1 : Sort, arg2 : Sort, res : Sort) extends IndexedFunctionSymbol {
//      val sort = res
//      val name = "Floating Point Addition with " + sort
//      val toSMTLib = "fp.add"
//      val args = List(RoundingModeSort, arg1, arg2)
//      val getFactory = thisFactory
//    }
//
//    val rank = 1
//    override def apply(sorts : Seq[Sort]) = {
//      op match {
//        // TODO: Pass integers instead of sorts?
//        case "fp.add" => new FPAddFunctionSymbol(sorts(0), sorts(1), sorts(2)) 
//      }
//      
//    }
//    
//    // TODO: Unapply should check if the argument symbol is of a instance fpfunctionsymbol and then pick it apart
//    // def unapply(FunctionSymbol : TypedFunctionSymbol) 
//    
//  }

//    val fp2_2 = FPFactory(List(2, 2))
//    println("fp2_2: (" + fp2_2.getClass + ") = " + fp2_2)
//    val fpAddFactory = new FPOpFactory("fp.add")
//    val fpAdd2_2 = fpAddFactory(List(fp2_2, fp2_2, fp2_2))
//    println("fpAdd2_2: (" + fpAdd2_2.getClass + ") = " + fpAdd2_2)
